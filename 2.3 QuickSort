Quicksort:
  The idea is that for some j, arry[j] is in place. 
  So that no entry to the left of j is greater than arry[j]
  and no entry to the left of j is smaller than arry[j]
  Then sort each piece recursively. 
  
  #include <iostream>
 
  using namespace std;
 
  void Qsort(int a[], int low, int high)
    {
     if(low >= high)
      {
        return;
     }
      int first = low;
      int last = high;
      int key = a[first];/*用字表的第一个记录作为枢轴*/
 
      while(first < last)
     {
        while(first < last && a[last] >= key)
        {
            --last;
        }
 
        a[first] = a[last];/*将比第一个小的移到低端*/
 
        while(first < last && a[first] <= key)
        {
            ++first;
        }
         
        a[last] = a[first];    
      /*将比第一个大的移到高端*/
      }
    a[first] = key;/*枢轴记录到位*/
    Qsort(a, low, first-1);
    Qsort(a, first+1, high);
  }
  int main()
  {
    int a[] = {57, 68, 59, 52, 72, 28, 96, 33, 24};
 
    Qsort(a, 0, sizeof(a) / sizeof(a[0]) - 1);/*这里原文第三个参数要减1否则内存越界*/
 
    for(int i = 0; i < sizeof(a) / sizeof(a[0]); i++)
    {
        cout << a[i] << "";
    }
     
    return 0;
  }/*参考数据结构p274(清华大学出版社，严蔚敏)*/
